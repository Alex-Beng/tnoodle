#!/usr/bin/python

from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from os.path import exists, dirname, join, isdir, split, abspath, relpath, basename
import sys, os, imp, re, subprocess, shutil, shlex
import zipfile
import tempfile

def windowsOrCygwin():
	return sys.platform == 'win32' or sys.platform == 'cygwin'

if windowsOrCygwin():
	def windowsSymlink(src, linkName):
		parentDir, fileName = split(linkName)
		assert isdir(parentDir)
		src = src.replace('/', '\\')
		assert 0 == os.system("cmd /C \"cd %s && mklink /D %s %s\"" % ( parentDir, fileName, src ) )
	def islink(path):
		return readlink(path) != None
	def readlink(path):
		parentDir, fileName = split(path)
		p = subprocess.Popen([ 'dir', parentDir ], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		stdout, stderr = p.communicate()
		assert p.returncode == 0
		files = stdout.split('\n')
		symlinkRe = re.compile(r'.*SYMLINKD.*%s.*\[(.*)\].*' % fileName) # lol, this is crazy fragile
		for file in files:
			match = symlinkRe.match(file)
			if match:
				return match.group(1).replace('\\', '/')
		return None
	oldUnlink = os.unlink
	def unlink(path):
		if islink(path):
			# For some reason, Windows refuses to delete a symlink when using
			# the hacked version of islink I've create above.
			assert 0 == os.system('rmdir %s' % path)
		else:
			oldUnlink(path)
	
	os.unlink = unlink
	os.symlink = windowsSymlink
	os.path.islink = islink
	os.readlink = readlink
	
def rmtree(dir):
	# This method recursively deletes a directory, but doesn't follow any symlinks
	def onerror(func, path, excinfo):
		if func == os.path.islink:
			os.unlink(path)
			#<<<assert 0 == os.system('rmdir %s' % path)
		else:
			import pdb; pdb.set_trace() #<<< TODO - how to properly reraise the exception?
			raise excinfo
	shutil.rmtree(dir, onerror=onerror)

PROJECT_FILE_NAME = 'tmtproject'
DEFAULT_PROJECT_NAME = 'all'

def dfs(node, path=()):
	assert node not in path, "Not a dag!"
	visted = [ node, ]
	path += ( node, )
	for child in node.getDependencies():
		visted += dfs(child, path)
	return visted

def rightPrune(nodes):
	prunedNodes = []
	for node in reversed(nodes):
		if node not in prunedNodes:
			prunedNodes.insert(0, node)
	return prunedNodes

def isTopologicalSort(sortedNodes):
	for i, node in enumerate(sortedNodes):
		for child in node.getDependencies():
			childIndex = sortedNodes.index(child)
			assert childIndex != i
			if childIndex < i:
				return False
	return True

def topologicalSort(rootProject):
	visitedNodes = dfs(rootProject)
	visitedNodes = rightPrune(visitedNodes)
	assert isTopologicalSort(visitedNodes)
	return visitedNodes

class tmt:

	def _cdEntryPoint(self):
		os.chdir(split(abspath(__file__))[0])
		assert exists('README.textile')

	def _loadTmtProjects(self):
		self._cdEntryPoint()
		projectFiles = ( join(dir, PROJECT_FILE_NAME) for dir in os.listdir('.') )
		for projectFile in sorted(filter(exists, projectFiles)):
			projectName = dirname(projectFile)
			imp.load_source(projectFile, projectFile)
			assert dirname(projectFile) in tmt.TmtProject.projects
		
		assert DEFAULT_PROJECT_NAME in tmt.TmtProject.projects, tmt.TmtProject.projects.keys()
		defaultProject = tmt.TmtProject.projects[ DEFAULT_PROJECT_NAME ]

		for projectName, project in sorted(tmt.TmtProject.projects.iteritems()):
			project.afterProjects()

		tmt.TmtProject.sortedProjects = topologicalSort(defaultProject)
		for project in reversed(tmt.TmtProject.sortedProjects):
			project.configure()

	def _main(self):
		self._loadTmtProjects()
		self.args = tmt.parser.parse_args()
		self.args.func()

	def _graph(self):
		if tmt.args.file:
			# TODO look at tmt.args.file and generate a dotty file or something?
			assert False, "not yet implemented"
		else:
			print tmt.TmtProject.projects[tmt.args.project].prettyDependencies()

	def _make(self, projectName=None, command=None):
		if projectName == None:
			projectName = tmt.args.project
		if command == None:
			command = tmt.args.command
		project = tmt.TmtProject.projects[projectName]
		recurse = not tmt.args.no_recursive
		dist = False
		if recurse:
			noRecurseCommands = [ 'run', 'dist' ]
			if command in noRecurseCommands:
				print "WARNING: recurse makes no sense with the following commands: %s, so I'm ignoring it" % noRecurseCommands
				recurse = False
		if recurse:
			projects = project.getRecursiveDependenciesTopoSorted()
		else:
			projects = [ project ]

		projects.reverse()
		for project in projects:
			commandFunc = getattr(project, command, None)
			assert commandFunc, 'No %s target in %s' % ( command, project )
			commandFunc()

	def __init__(self):
		self.parser = ArgumentParser(
			description='tmt, the Tnoodle Make Tools',
			formatter_class=ArgumentDefaultsHelpFormatter)
		subparsers = self.parser.add_subparsers(help='Available commands')

		desc = 'Make stuff'
		parser_make = subparsers.add_parser(
			'make',
			help=desc, description=desc,
			formatter_class=ArgumentDefaultsHelpFormatter)
		parser_make.add_argument(
			'--project', '-p',
			default=DEFAULT_PROJECT_NAME,
			type=str,
			help='the project to build')
		parser_make.add_argument(
			'--no-recursive', '-nr',
			default=False,
			action='store_true',
			help='do not apply command recursively to dependencies')
		parser_make.add_argument(
			'command',
			nargs='?',
			choices=['compile', 'dist', 'run', 'clean'],
			default='compile',
			help='command!')
		parser_make.add_argument(
			'--args', '-a',
			default='',
			help='Command line arguments (only valid with the "run" command)')
		parser_make.add_argument(
			'--debug', '-d',
			choices=['jdb', 'attach'],
			default=None,
			help='Run with jdb or as an attacheable vm (only valid with the "run" command)')
		parser_make.set_defaults(func=self._make)

		desc = 'Generate dependency graph'
		parser_graph = subparsers.add_parser(
			'graph',
			help=desc, description=desc,
			formatter_class=ArgumentDefaultsHelpFormatter)
		parser_graph.add_argument(
			'--file', '-f',
			default='', type=str,
			help='')
		parser_graph.add_argument(
			'--project', '-p',
			default=DEFAULT_PROJECT_NAME, type=str,
			help='the project to build')
		parser_graph.add_argument(
			'--timestamps', '-t',
			action="store_true", default=False,
			help='Show project timestamps for debugging purposes')
		parser_graph.add_argument(
			'--no-prune', '-np',
			action="store_true", default=False,
			help='Do not prune duplicate projects')
		parser_graph.set_defaults(func=self._graph)
	
	def memoize(self, func):
		d = {}
		evaluating = set()
		def memoed(*args):
			if not args in d:
				assert not args in evaluating, "Memoized functions may not have cycles!"
				evaluating.add(args)
				d[args] = func(*args)
				evaluating.remove(args)
			return d[args]
		return memoed

	def projectName(self):
		import traceback
		projectName, projectFileName = traceback.extract_stack()[-2][0].split(os.sep)
		assert isdir(projectName)
		assert projectFileName == PROJECT_FILE_NAME
		return projectName

	def timestamp(self, f):
		"""
			If f is a directory, returns the timestamp of the newest file 
			found anywhere under the given directory f.
			If f is a file, simply returns the timestamp of the given file.
			Empty directories have timestamp 0.
		"""
		if os.path.islink(f):
			# We don't follow symbolic links because we don't want them
			# to cause a recompile of any project that uses us.
			return os.lstat(f).st_mtime
		if not isdir(f):
			try:
				return os.lstat(f).st_mtime
			except:
				import traceback
				traceback.print_exc()
				import pdb; pdb.set_trace()

		m = 0
		for ff in os.listdir(f):
			m = max(m, self.timestamp(join(f, ff)))
		return m
	
	def glob(self, folder, pattern, relativeTo=None):
		matches = []
		pattern = re.compile(pattern)
		if relativeTo is None:
			relativeTo = '.'
		for root, dirs, files in os.walk(folder):
			matches += [ relpath(join(root, f), relativeTo) for f in files if pattern.match(f) ]
		return matches

	def java(self, main, classpath='', args=[], debug=False):
		command = []
		assert debug in [ None, 'jdb', 'attach' ]
		if debug == 'jdb':
			command.append('jdb')
			# TODO - passing -ea to jdb doesn't work! I HATE JAVA
		else:
			command.append('java')
			if debug == 'attach':
				command.append('-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n') # TODO - configurable port?
			command.append('-ea') # TODO - should turn on assertions at runtime
		if classpath:
			command.append('-classpath')
			command.append(classpath)
		command.append(main)
		command += args
		print " ".join(command)
		p = subprocess.Popen(command)
		return p.wait()

tmt = tmt() # We only want one instance of Tmt
sys.modules['tmt'] = tmt

class TmtProject(object):
	projects = {}
	def __init__(self, name):
		self.name = name
		assert not name in TmtProject.projects, name
		TmtProject.projects[name] = self
	def __str__(self, timestamps=False):
		return self.name
	# The configure method of each project gets called in reverse
	# dependency order. That is, if a project A uses a project B,
	# B.configure() will be called before A.configure().
	def configure(self):
		pass
	# The afterProjects method gets called for each project after all the projects
	# have been loaded, in no particular order.
	def afterProjects(self):
		pass
	def compile(self):
		assert False
	def dist(self):
		assert False
	def run(self):
		assert False
	def clean(self):
		assert False
	def getDependencies(self):
		assert False
	def getRecursiveDependenciesTopoSorted(self):
		assert self in tmt.TmtProject.sortedProjects
		projectIndex = tmt.TmtProject.sortedProjects.index(self)
		projects = tmt.TmtProject.sortedProjects[projectIndex:]
		return projects
	def prettyDependencies(self, level=0, printingLevels=None, seen=None):
		if printingLevels == None:
			assert level == 0
			printingLevels = set([0])
		else:
			printingLevels = printingLevels.copy()
		if seen == None:
			assert level == 0
			seen = set()
		indent = ''
		for i in range(level):
			if i == level-1:
				if not i in printingLevels:
					indent += '`-- '
				else:
					indent += '|-- '
			else:
				if i in printingLevels:
					indent += '|   '
				else:
					indent += '    '

		if not tmt.args.no_prune and self in seen:
			# If we're pruning, and we've seen this node before,
			# then we don't recurse
			s = indent + self.__str__(timestamps=tmt.args.timestamps) + ' (seen)\n'
		else:
			s = indent + self.__str__(timestamps=tmt.args.timestamps) + '\n'
			printingLevels.add(level)
			dependencies = self.getDependencies()
			for p in dependencies:
				if p == dependencies[-1]:
					printingLevels.remove(level)
				s += p.prettyDependencies(level+1, printingLevels, seen)
				seen.add(p)
		return s
tmt.TmtProject = TmtProject

@tmt.memoize
def createJarDependency(jarFile):
	return JarDependency(jarFile)

class JarDependency(TmtProject):
	def __init__(self, jarFile):
		self.jarFile = jarFile
		TmtProject.__init__(self, basename(jarFile))
	def getDependencies(self):
		return []
	def compile(self):
		pass
	def clean(self):
		pass
	def __str__(self, timestamps=False):
		s = self.name
		if timestamps:
			s += ' %s' % tmt.timestamp(self.jarFile)
		return s

class EclipseProject(TmtProject):
	from xml.sax import make_parser, saxutils

	class EclipseClasspathHandler(saxutils.handler.ContentHandler):
		def startDocument(self):
			self.jarFiles = []
			self.projects = []

		def startElement(self, name, attrs):
			if name == 'classpathentry':
				kind = attrs.get('kind')
				path = attrs.get('path')
				if kind == 'output':
					assert path == 'bin'
				elif kind == 'src':
					if path.startswith('/'):
						self.projects.append(path[1:])
					else:
						assert path == 'src'
				elif kind == 'lib':
					assert path.startswith('/')
					self.jarFiles.append(abspath(path[1:]))
				elif kind == 'con':
					pass
				else:
					assert False, 'Unrecognized kind: %s' % kind
	classpathParser = make_parser()
	classpathHandler = EclipseClasspathHandler()
	classpathParser.setContentHandler(classpathHandler)

	def __init__(self, name, main=None):
		self.main = main
		self.nonJavaSrcDeps = []
		TmtProject.__init__(self, name)

	def getDependencies(self):
		return self.jars + self.projects

	def getClasspathEntities(self):
		classpath = set()
		classpath |= set(relpath(jar.jarFile) for jar in self.jars)
		classpath.add(self.bin)

		# TODO - the src folder only needs to be in the classpath so
		# jdb can discover the source code
		classpath.add(self.src)
		# TODO - I hate the world
		# Uncomment & replace the following with the path to your jre
		# if you're trying to use jbd inside of a java library method.
		#classpath.add('/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0.x86_64/src')

		for project in self.projects:
			classpath |= project.getClasspathEntities()
		return classpath

	def getClasspath(self):
		separator = None
		if windowsOrCygwin():
			separator = ';'
		else:
			separator = ':'
		return separator.join(self.getClasspathEntities())

	def afterProjects(self):
		dependencyFile = join(self.name, '.classpath')
		assert exists(dependencyFile), dependencyFile
		EclipseProject.classpathParser.parse(dependencyFile)
		self.jars = [ createJarDependency(jar) for jar in EclipseProject.classpathHandler.jarFiles ]
		self.projects = [ tmt.TmtProject.projects[p] for p in EclipseProject.classpathHandler.projects ]
		self.bin = join(self.name, 'bin')
		self.distDir = join(self.name, 'dist')
		self.src = join(self.name, 'src')
		if not isdir(self.bin):
			os.mkdir(self.bin)
		if not isdir(self.distDir):
			os.mkdir(self.distDir)

	def compile(self):
		tempBin = join(self.name, '.bin')

		lastCompiled = tmt.timestamp(self.bin)
		depsLastTouched = ( ( tmt.timestamp(dep), dep ) for dep in self.getClasspathEntities() )
		changedDeps = filter( lambda ( ts, dep ): ts > lastCompiled, depsLastTouched )
		srcLastTouched = tmt.timestamp(self.src)
		if lastCompiled > srcLastTouched and len(changedDeps) == 0:
			print "%s is up to date, not recompiling" % self.name
			return

		print 'Compiling: %s' % self.name

		rmtree(self.bin)
		if isdir(tempBin):
			rmtree(tempBin)
		os.mkdir(tempBin)

		javaFiles = tmt.glob(self.src, r'.*\.java$')
		if len(javaFiles) > 0:
			args = [ 'javac' ]
			args += [ '-d', tempBin ]
			classpath = self.getClasspath()
			if classpath:
				args += [ '-classpath', classpath ]
			args += javaFiles
			p = subprocess.Popen(args)
			print " ".join(args)
			assert p.wait() == 0, 'javac failed!'

		for nonJavaSrcDep in self.nonJavaSrcDeps:
			srcPath = join(self.src, nonJavaSrcDep)
			binPath = join(tempBin, nonJavaSrcDep)
			print "Copying %s -> %s" % ( srcPath, binPath )
			if isdir(srcPath):
				# If this dependency is a directory, we symlink to it
				# this way, we can get some changes without recompiling.
				parentDir = dirname(dirname(binPath))
				if not isdir(parentDir):
					os.makedirs(parentDir)
				if binPath.endswith('/'):
					binPath = binPath[:-1]
				srcPath = abspath(srcPath)
				srcPath = relpath(srcPath, parentDir)
				os.symlink(srcPath, binPath)
			else:
				assert not isdir(binPath)
				parentDir = dirname(binPath)
				if not isdir(parentDir):
					os.makedirs(parentDir)
				shutil.copy(srcPath, binPath)

		print 'Compiled successfully! Renaming %s -> %s' % ( tempBin, self.bin )
		os.rename(tempBin, self.bin)
	
	def dist(self):
		# TODO - check if existing archive is up to date
		# TODO - support for version numbers?
		tmt._make(projectName=self.name, command='compile')
		capName = self.name[0].upper() + self.name[1:]
		jarName = join(self.distDir, 'TNoodle%s.jar' % capName)
		jar = zipfile.ZipFile(jarName, "w", compression=zipfile.ZIP_DEFLATED)

		jarDeps = []
		javaDeps = []
		for project in self.getRecursiveDependenciesTopoSorted():
			if hasattr(project, 'jarFile'):
				jarDeps.append(project)
			else:
				javaDeps.append(project)
		if jarDeps:
			extractedLibDir = tempfile.mkdtemp()
			for jarDep in jarDeps:
				jarLib = zipfile.ZipFile(jarDep.jarFile)
				jarLib.extractall(path=extractedLibDir)
			for dirpath, dirnames, filenames in os.walk(extractedLibDir):
				for name in filenames:
					path = os.path.normpath(os.path.join(dirpath, name))
					arcPath = os.path.relpath(path, extractedLibDir)
					if os.path.isfile(path):
						jar.write(path, arcPath)
			rmtree(extractedLibDir)

		for project in javaDeps:
			for dirpath, dirnames, filenames in os.walk(project.bin, followlinks=True):
				for name in filenames:
					path = os.path.normpath(os.path.join(dirpath, name))
					arcPath = os.path.relpath(path, project.bin)
					if os.path.isfile(path):
						jar.write(path, arcPath)

		manifest = """\
Manifest-Version: 1.0
Main-Class: %s
""" % ( self.main )
		jar.writestr('META-INF/MANIFEST.MF', manifest)

		jar.close()

		print 'Successfully created %s with main class %s' % ( jarName, self.main )

	def run(self):
		assert self.main, 'Main class not defined'
		assert tmt.args.args is not None # shlex reads from stdin if you pass None, lol
		tmt._make(projectName=self.name, command='compile')
		# TODO propogate return code up
		tmt.java(
			main=self.main,
			classpath=self.getClasspath(),
			args=shlex.split(tmt.args.args),
			debug=tmt.args.debug)

	def clean(self):
		print 'Cleaning: %s' % self.name
		assert isdir(self.bin)
		assert isdir(self.distDir)
		rmtree(self.bin)
		rmtree(self.distDir)
		tempBin = join(self.name, '.bin')
		if isdir(tempBin):
			rmtree(tempBin)
	
	def __str__(self, timestamps=False):
		s = self.name
		if timestamps:
			binTs = tmt.timestamp(self.bin)
			srcTs = tmt.timestamp(self.src)
			s += ' bin: %s src: %s' % ( binTs, srcTs )
		return s

tmt.EclipseProject = EclipseProject

if __name__ == "__main__":
	tmt._main()
