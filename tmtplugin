#!/usr/bin/python

import tmt
from os.path import join, abspath, exists
from argparse import ArgumentDefaultsHelpFormatter
from xml.sax import make_parser, saxutils

ROOT_PROJECT = 'server'
def pluginsLoaded():
	assert ROOT_PROJECT in tmt.pluginMap

class EclipseClasspathHandler(saxutils.handler.ContentHandler):
	def startDocument(self):
		self.jarFiles = []
		self.projects = []

	def startElement(self, name, attrs):
		if name == 'classpathentry':
			kind = attrs.get('kind')
			path = attrs.get('path')
			if kind == 'output':
				assert path == 'bin'
			elif kind == 'src':
				if path.startswith('/'):
					self.projects.append(path[1:])
				else:
					assert path == 'src'
			elif kind == 'lib':
				assert path.startswith('/')
				self.jarFiles.append(abspath(path[1:]))
			elif kind == 'con':
				pass
			else:
				assert False, 'Unrecognized kind: %s' % kind
classpathParser = make_parser()
classpathHandler = EclipseClasspathHandler()
classpathParser.setContentHandler(classpathHandler)

@tmt.memoize
def buildDependencyTree(project=ROOT_PROJECT):
	dependencyFile = join(project, '.classpath')
	assert exists(dependencyFile)
	global classpathParser, classpathHandler
	classpathParser.parse(dependencyFile)
	jars = classpathHandler.jarFiles
	projects = classpathHandler.projects
	for i, childProject in enumerate(projects):
		projects[i] = buildDependencyTree(childProject)
	return ( project, jars, projects )

def tree2str(tree, level=0, printingLevels=None, seen=None):
	if printingLevels == None:
		assert level == 0
		printingLevels = set([0])
	else:
		printingLevels = printingLevels.copy()
	if seen == None:
		assert level == 0
		seen = set()
	indent = ''
	for i in range(level):
		if i == level-1:
			if not i in printingLevels:
				indent += '`-- '
			else:
				indent += '|-- '
		else:
			if i in printingLevels:
				indent += '|   '
			else:
				indent += '    '

	if isinstance(tree, basestring):
		s = indent + tree + '\n'
	else:
		project, jars, projects = tree
		s = "%s%s\n" % ( indent, project )
		printingLevels.add(level)
		all = jars + projects
		for p in all:
			if p == all[-1]:
				printingLevels.remove(level)
			if tmt.args.prune and not isinstance(p, basestring):
				if p[0] in seen:
					p = '%s (seen)' % p[0]
				else:
					seen.add(p[0])
			s += tree2str(p, level+1, printingLevels, seen)
	return s

def graph():
	tree = buildDependencyTree()
	if tmt.args.file:
		# TODO look at tmt.args.file and generate a dotty file or something?
		assert False, "not yet implemented"
	else:
		print tree2str(tree)

def make():
	project = tmt.args.project
	projectPath = abspath(project)
	projectPlugin = tmt.pluginMap.get(project, None)
	assert projectPlugin, 'Project "%s" not found in %s' % ( project,
		tmt.pluginMap.keys() )
	command = tmt.args.command
	configureFunc = getattr(projectPlugin, 'configure', None)
	if configureFunc:
		configureFunc(projectPath)
	commandFunc = getattr(projectPlugin, command, None)
	assert commandFunc, '%s function not found in %s' % ( command, project )
	commandFunc(projectPath)


subparsers = tmt.parser.add_subparsers(help='Available commands')

desc = 'Make stuff'
parser_make = subparsers.add_parser(
	'make',
	help=desc, description=desc,
	formatter_class=ArgumentDefaultsHelpFormatter)
#parser_make.add_argument('bar', type=int, help='bar help')
parser_make.add_argument(
	'--project', '-p', default=ROOT_PROJECT, type=str, help='the project to build')
parser_make.add_argument(
	'command',
	nargs='?',
	choices=['compile', 'dist', 'run', 'clean'],
	default='compile',
	help='command!')
parser_make.set_defaults(func=make)

desc = 'Generate dependecy graph'
parser_graph = subparsers.add_parser(
	'graph',
	help=desc, description=desc,
	formatter_class=ArgumentDefaultsHelpFormatter)
parser_graph.add_argument(
	'--file', '-f', default='', type=str, help='')
parser_graph.add_argument(
	'--prune', '-p', action="store_true", help='Prune duplicate projects')
parser_graph.set_defaults(func=graph)
