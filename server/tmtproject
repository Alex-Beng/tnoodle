#!/usr/bin/python

import tmt
import os
from os.path import join, exists, relpath
import shutil

SERVER_PLUGIN_DIR = 'serverPlugins'
CONTEXT_FILE = 'context'

class Project(tmt.EclipseProject):
	def __init__(self, *args, **kwargs):
		tmt.EclipseProject.__init__(
				self,
				tmt.projectName(),
				main='net.gnehzr.tnoodle.server.TNoodleServer')
		self.plugins = []

	def addPlugin(self, project):
		project.serverPluginSrcDir = join(project.src, SERVER_PLUGIN_DIR)
		project.contextFileName = join(project.serverPluginSrcDir, CONTEXT_FILE)
		assert exists(join(project.serverPluginSrcDir, project.name))
		project.serverPluginBinDir = join(project.bin, SERVER_PLUGIN_DIR)
		project.serverPluginPackageBinDir = join(project.serverPluginBinDir, project.name)
		project.main = self.main
		assert exists(project.contextFileName)
		self.plugins.append(project)

	def configure(self):
		tmt.Server = self
		tmt.EclipseProject.configure(self)
		self.addPlugin(self)
		wwwDir = relpath(join(self.serverPluginSrcDir, 'www'), self.src)
		# TODO - add support for globbed stuff to EclipseProject
		#self.nonJavaSrcDeps = tmt.glob(wwwDir, '.*', relativeTo=self.src)
		self.nonJavaSrcDeps = [ wwwDir ]

	# Copied (and modified) from /usr/lib64/python2.7/shutil.py
	def copytreeIgnoreExistingDstDir(self, src, dst, symlinks=False, ignore=None):
		import os
		names = os.listdir(src)
		if ignore is not None:
			ignored_names = ignore(src, names)
		else:
			ignored_names = set()

		if not os.path.isdir(dst):
			os.makedirs(dst)
		errors = []
		for name in names:
			if name in ignored_names:
				continue
			srcname = os.path.join(src, name)
			dstname = os.path.join(dst, name)
			try:
				if symlinks and os.path.islink(srcname):
					linkto = os.readlink(srcname)
					os.symlink(linkto, dstname)
				elif os.path.isdir(srcname):
					self.copytreeIgnoreExistingDstDir(srcname, dstname, symlinks, ignore)
				else:
					# Will raise a SpecialFileError for unsupported file types
					# TODO - what happens if dstname exists?!
					shutil.copy2(srcname, dstname)
			# catch the Error from the recursive copytree so that we can
			# continue with other files
			except shutil.Error, err:
				#<<< This is not right, but nor is my fix
				#errors.extend(err.args[0])
				errors.extend(err.args)
			except EnvironmentError, why:
				errors.append((srcname, dstname, str(why)))
		try:
			shutil.copystat(src, dst)
		except OSError, why:
			if WindowsError is not None and isinstance(why, WindowsError):
				# Copying file access times may fail on Windows
				pass
			else:
				errors.extend((src, dst, str(why)))
		if errors:
			raise shutil.Error, errors

	def afterCompile(self, compiledProjects):
		# Fortunately, the way we're copying files preserves the timestamps,
		# so it doesn't make the server binaries look any newer than they should.
		context = ''
		for project in self.plugins:
			if project not in compiledProjects:
				# If plugin A uses plugin B (which both, of course, use this
				# project), and the developer chooses to compile plugin B, we
				# don't want to load the plugin for A. The compiledProjects
				# argument helps us avoid that.
				continue
			contextFileName = project.contextFileName
			assert exists(contextFileName)

			if project != self:
				linkName = join(self.serverPluginBinDir, project.name)
				dest = relpath(project.serverPluginPackageBinDir, self.serverPluginBinDir)
				linkUpToDate = False
				if os.path.islink(linkName):
					linkTo = os.readlink(linkName)
					if linkTo == dest:
						linkUpToDate = True
				if not linkUpToDate:
					if exists(linkName):
						os.unlink(linkName)
					os.symlink(dest, linkName)
				# TODO - it would be nice to assert no files get clobbered
				#self.copytreeIgnoreExistingDstDir(project.serverPluginBinDir, self.serverPluginBinDir)

			inputContextFile = file(contextFileName, 'r')
			context += inputContextFile.read() + '\n'

		outputContextFileName = join(self.serverPluginBinDir, CONTEXT_FILE)
		contextFileUpToDate = False
		if exists(outputContextFileName):
			outputContextFile = file(outputContextFileName, 'r')
			contextFileUpToDate = ( outputContextFile.read() == context )
		if not contextFileUpToDate:
			outputContextFile = file(outputContextFileName, 'w')
			outputContextFile.write(context)

Project()
